
Creating a "To-Do List" program in Go that allows for managing tasks with an ID, task name, start date, end date, status, and printing the list to both a file/database and a PDF document is an interesting project. I'll walk you through the steps to implement this functionality.

### Features of the To-Do List:
1. **Task Structure:**
   - ID (unique identifier)
   - Task name
   - Start date
   - End date
   - Status (pending, in progress, completed)

2. **Storage Options:**
   - Save to a file (e.g., JSON file).
   - Save to a database (SQLite in this case).
   - Print tasks to a PDF document.

### Go Libraries to Use:
- **`encoding/json`**: For saving tasks to a JSON file.
- **`github.com/jung-kurt/gofpdf`**: For generating PDF documents.
- **`github.com/mattn/go-sqlite3`**: For interacting with an SQLite database.

### Step 1: Install Required Go Packages

First, install the dependencies using `go get`:

```bash
go get github.com/jung-kurt/gofpdf
go get github.com/mattn/go-sqlite3
```

### Step 2: Define the Task Structure and Basic Functionality

Create a `main.go` file to manage the tasks.

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"time"
	"github.com/jung-kurt/gofpdf"
	"github.com/mattn/go-sqlite3"
	"database/sql"
)

type Task struct {
	ID        int       `json:"id"`
	Task      string    `json:"task"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Status    string    `json:"status"`
}

var tasks []Task

// Function to add a task to the list
func addTask(task Task) {
	tasks = append(tasks, task)
}

// Function to save tasks to a JSON file
func saveToJSON(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(tasks)
}

// Function to save tasks to a SQLite database
func saveToDatabase(db *sql.DB) error {
	for _, task := range tasks {
		_, err := db.Exec(`INSERT INTO tasks (id, task, start_date, end_date, status) 
			VALUES (?, ?, ?, ?, ?)`, task.ID, task.Task, task.StartDate, task.EndDate, task.Status)
		if err != nil {
			return err
		}
	}
	return nil
}

// Function to generate a PDF of the tasks
func generatePDF(filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(190, 10, "To-Do List", 0, 1, "C")

	// Set table header
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "ID")
	pdf.Cell(50, 10, "Task")
	pdf.Cell(30, 10, "Start Date")
	pdf.Cell(30, 10, "End Date")
	pdf.Cell(30, 10, "Status")
	pdf.Ln(10)

	// Set task data
	for _, task := range tasks {
		pdf.Cell(40, 10, fmt.Sprintf("%d", task.ID))
		pdf.Cell(50, 10, task.Task)
		pdf.Cell(30, 10, task.StartDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.EndDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.Status)
		pdf.Ln(8)
	}

	// Save the file
	return pdf.OutputFileAndClose(filename)
}

// Function to initialize SQLite database
func initializeDatabase() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./todo.db")
	if err != nil {
		return nil, err
	}

	// Create table if it does not exist
	query := `CREATE TABLE IF NOT EXISTS tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);`
	_, err = db.Exec(query)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Function to load tasks from SQLite database
func loadFromDatabase(db *sql.DB) ([]Task, error) {
	rows, err := db.Query("SELECT id, task, start_date, end_date, status FROM tasks")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tasks []Task
	for rows.Next() {
		var task Task
		err := rows.Scan(&task.ID, &task.Task, &task.StartDate, &task.EndDate, &task.Status)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, task)
	}

	return tasks, nil
}

func main() {
	// Add some tasks for demonstration
	tasks = append(tasks, Task{
		ID:        1,
		Task:      "Write Go code",
		StartDate: time.Now(),
		EndDate:   time.Now().Add(2 * time.Hour),
		Status:    "Pending",
	})
	tasks = append(tasks, Task{
		ID:        2,
		Task:      "Test Go code",
		StartDate: time.Now().Add(1 * time.Hour),
		EndDate:   time.Now().Add(3 * time.Hour),
		Status:    "Pending",
	})

	// Save to JSON file
	err := saveToJSON("tasks.json")
	if err != nil {
		fmt.Println("Error saving to JSON:", err)
		return
	}
	fmt.Println("Tasks saved to tasks.json")

	// Initialize database
	db, err := initializeDatabase()
	if err != nil {
		fmt.Println("Error initializing database:", err)
		return
	}
	defer db.Close()

	// Save tasks to database
	err = saveToDatabase(db)
	if err != nil {
		fmt.Println("Error saving tasks to database:", err)
		return
	}
	fmt.Println("Tasks saved to database.")

	// Load tasks from database
	tasksFromDB, err := loadFromDatabase(db)
	if err != nil {
		fmt.Println("Error loading tasks from database:", err)
		return
	}
	fmt.Println("Tasks loaded from database:", tasksFromDB)

	// Generate a PDF
	err = generatePDF("tasks.pdf")
	if err != nil {
		fmt.Println("Error generating PDF:", err)
		return
	}
	fmt.Println("Tasks saved to tasks.pdf")
}
```

### Explanation:

1. **Task Structure (`Task`)**:
   - Each task has an ID, task description, start date, end date, and status.

2. **Functions**:
   - **addTask**: Adds a new task to the `tasks` slice.
   - **saveToJSON**: Saves tasks as a JSON file.
   - **saveToDatabase**: Saves tasks into an SQLite database.
   - **generatePDF**: Creates a PDF file with all tasks.
   - **initializeDatabase**: Initializes the SQLite database.
   - **loadFromDatabase**: Loads tasks from the SQLite database.

3. **SQLite Database**:
   - The database stores tasks in a table with columns: `id`, `task`, `start_date`, `end_date`, and `status`.

4. **Generating a PDF**:
   - We use the `gofpdf` library to generate a PDF containing the task list.

### Step 3: Create and Run the Program

1. Create a folder for your Go program (e.g., `go-todo`).
2. Inside that folder, create a `main.go` file and paste the code above.
3. Run the program using:

```bash
go run main.go
```

This will:
- Add a couple of tasks.
- Save the tasks to a JSON file (`tasks.json`).
- Save the tasks to an SQLite database (`todo.db`).
- Load tasks from the database.
- Generate a PDF file (`tasks.pdf`) with the tasks.

### Conclusion

This simple "To-Do List" program in Go allows you to:
- Add, save, and load tasks from both a file (JSON) and a database (SQLite).
- Generate a PDF document of the task list.

You can extend the program by adding more functionalities such as:
- Editing or deleting tasks.
- Adding more metadata (e.g., priority, category).
- Integrating a user interface.

Let me know if you need further improvements or additions!
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

To make the "To-Do List" program more interactive for the user, we can add user input features that allow the user to interact with the program in real-time. This means the user will be able to:

1. **Add new tasks.**
2. **View the existing tasks.**
3. **Edit tasks.**
4. **Delete tasks.**
5. **Save the tasks to a JSON file or SQLite database.**
6. **Generate a PDF of the tasks.**

We'll use a command-line interface (CLI) for this interaction. The user will be prompted for input, and based on their choice, different operations will be performed.

### Step 1: Modify the Program for Interactivity

I'll update the code to include a simple text-based menu that prompts the user for options.

### Full Interactive To-Do List in Go

```go
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/jung-kurt/gofpdf"
	_ "github.com/mattn/go-sqlite3"
)

type Task struct {
	ID        int       `json:"id"`
	Task      string    `json:"task"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Status    string    `json:"status"`
}

var tasks []Task

// Function to add a task to the list
func addTask() {
	var taskName, status string
	var startDate, endDate string

	// Prompt user for task details
	fmt.Println("Enter task name:")
	fmt.Scanln(&taskName)

	fmt.Println("Enter start date (YYYY-MM-DD):")
	fmt.Scanln(&startDate)

	fmt.Println("Enter end date (YYYY-MM-DD):")
	fmt.Scanln(&endDate)

	fmt.Println("Enter status (Pending/In Progress/Completed):")
	fmt.Scanln(&status)

	// Convert string to time.Time
	start, err := time.Parse("2006-01-02", startDate)
	if err != nil {
		fmt.Println("Invalid start date format.")
		return
	}

	end, err := time.Parse("2006-01-02", endDate)
	if err != nil {
		fmt.Println("Invalid end date format.")
		return
	}

	// Generate new ID for the task
	newID := len(tasks) + 1

	// Create and add the task to the list
	task := Task{
		ID:        newID,
		Task:      taskName,
		StartDate: start,
		EndDate:   end,
		Status:    status,
	}
	tasks = append(tasks, task)

	fmt.Println("Task added successfully!")
}

// Function to list all tasks
func listTasks() {
	if len(tasks) == 0 {
		fmt.Println("No tasks available.")
		return
	}

	fmt.Println("ID\tTask\t\tStart Date\tEnd Date\tStatus")
	fmt.Println("----------------------------------------------------------")
	for _, task := range tasks {
		fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
	}
}

// Function to save tasks to a JSON file
func saveToJSON(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(tasks)
}

// Function to save tasks to a SQLite database
func saveToDatabase(db *sql.DB) error {
	for _, task := range tasks {
		_, err := db.Exec(`INSERT INTO tasks (id, task, start_date, end_date, status) 
			VALUES (?, ?, ?, ?, ?)`, task.ID, task.Task, task.StartDate, task.EndDate, task.Status)
		if err != nil {
			return err
		}
	}
	return nil
}

// Function to generate a PDF of the tasks
func generatePDF(filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(190, 10, "To-Do List", 0, 1, "C")

	// Set table header
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "ID")
	pdf.Cell(50, 10, "Task")
	pdf.Cell(30, 10, "Start Date")
	pdf.Cell(30, 10, "End Date")
	pdf.Cell(30, 10, "Status")
	pdf.Ln(10)

	// Set task data
	for _, task := range tasks {
		pdf.Cell(40, 10, fmt.Sprintf("%d", task.ID))
		pdf.Cell(50, 10, task.Task)
		pdf.Cell(30, 10, task.StartDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.EndDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.Status)
		pdf.Ln(8)
	}

	// Save the file
	return pdf.OutputFileAndClose(filename)
}

// Function to initialize SQLite database
func initializeDatabase() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./todo.db")
	if err != nil {
		return nil, err
	}

	// Create table if it does not exist
	query := `CREATE TABLE IF NOT EXISTS tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);`
	_, err = db.Exec(query)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Function to load tasks from SQLite database
func loadFromDatabase(db *sql.DB) ([]Task, error) {
	rows, err := db.Query("SELECT id, task, start_date, end_date, status FROM tasks")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tasks []Task
	for rows.Next() {
		var task Task
		err := rows.Scan(&task.ID, &task.Task, &task.StartDate, &task.EndDate, &task.Status)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, task)
	}

	return tasks, nil
}

func main() {
	// Initialize SQLite database
	db, err := initializeDatabase()
	if err != nil {
		fmt.Println("Error initializing database:", err)
		return
	}
	defer db.Close()

	// Menu Loop
	for {
		fmt.Println("\nTo-Do List Menu:")
		fmt.Println("1. Add Task")
		fmt.Println("2. List Tasks")
		fmt.Println("3. Save to JSON File")
		fmt.Println("4. Save to Database")
		fmt.Println("5. Load from Database")
		fmt.Println("6. Generate PDF")
		fmt.Println("7. Exit")

		var choice int
		fmt.Print("Enter your choice: ")
		fmt.Scanln(&choice)

		switch choice {
		case 1:
			addTask()
		case 2:
			listTasks()
		case 3:
			err := saveToJSON("tasks.json")
			if err != nil {
				fmt.Println("Error saving to JSON:", err)
			} else {
				fmt.Println("Tasks saved to tasks.json")
			}
		case 4:
			err := saveToDatabase(db)
			if err != nil {
				fmt.Println("Error saving tasks to database:", err)
			} else {
				fmt.Println("Tasks saved to database.")
			}
		case 5:
			tasksFromDB, err := loadFromDatabase(db)
			if err != nil {
				fmt.Println("Error loading tasks from database:", err)
			} else {
				fmt.Println("Tasks loaded from database:")
				for _, task := range tasksFromDB {
					fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
				}
			}
		case 6:
			err := generatePDF("tasks.pdf")
			if err != nil {
				fmt.Println("Error generating PDF:", err)
			} else {
				fmt.Println("Tasks saved to tasks.pdf")
			}
		case 7:
			fmt.Println("Goodbye!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}
```

### Explanation of Changes:

1. **Interactive Menu:**
   - The program now includes a loop that presents the user with a menu of options.
   - The user can choose to add tasks, list tasks, save tasks to a file or database, generate a PDF, or exit the program.

2. **User Input:**
   - Users are prompted to enter task details such as the task name, start and end dates, and status when adding a task.
   - The program also handles invalid date formats.

3. **Saving to JSON/SQLite:**
   - Users can choose to save the tasks to a JSON file or an SQLite database.

4. **Generate PDF:**
   - Users can generate a PDF document of the tasks with their ID, name, start date, end date, and status.

5. **Database Integration:**
   - Users can load tasks from an SQLite database if they have previously saved tasks in it.

### How to Run:
1. **Install the dependencies** as shown previously:
   ```bash
   go get github.com/jung-kurt/gofpdf
   go get github.com/mattn/go-sqlite3
   ```

2. **Run the program**:
   ```bash
   go run main.go
   ```

### Sample Output:
After running the program, you will see the interactive menu:

```
To-Do List Menu:
1. Add Task
2. List Tasks
3. Save to JSON File
4. Save to Database
5. Load from Database
6. Generate PDF
7. Exit
Enter your choice: 1
```

From there, you can follow the prompts to add, list, save, or generate the PDF as needed.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
To implement the feature where completed tasks are moved to a new table and saved in a different JSON file, we need to add a few modifications to the program:

1. **Separate Completed Tasks:**
   - We'll need a function to "move" tasks that are marked as complete into a new table (`completed_tasks`).
   - Completed tasks will also be saved in a different JSON file.

2. **Database Schema Changes:**
   - We'll need to create a new table `completed_tasks` in the database for tasks that have been marked as completed.

3. **New JSON File:**
   - When a task is completed, it will be saved to a new JSON file (`completed_tasks.json`).

### Updated Code with Complete Tasks Handling

Here's how we can modify the program to achieve this:

### Full Interactive To-Do List with Completed Tasks in Go

```go
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/jung-kurt/gofpdf"
	_ "github.com/mattn/go-sqlite3"
)

type Task struct {
	ID        int       `json:"id"`
	Task      string    `json:"task"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Status    string    `json:"status"`
}

var tasks []Task
var completedTasks []Task

// Function to add a task to the list
func addTask() {
	var taskName, status string
	var startDate, endDate string

	// Prompt user for task details
	fmt.Println("Enter task name:")
	fmt.Scanln(&taskName)

	fmt.Println("Enter start date (YYYY-MM-DD):")
	fmt.Scanln(&startDate)

	fmt.Println("Enter end date (YYYY-MM-DD):")
	fmt.Scanln(&endDate)

	fmt.Println("Enter status (Pending/In Progress/Completed):")
	fmt.Scanln(&status)

	// Convert string to time.Time
	start, err := time.Parse("2006-01-02", startDate)
	if err != nil {
		fmt.Println("Invalid start date format.")
		return
	}

	end, err := time.Parse("2006-01-02", endDate)
	if err != nil {
		fmt.Println("Invalid end date format.")
		return
	}

	// Generate new ID for the task
	newID := len(tasks) + 1

	// Create and add the task to the list
	task := Task{
		ID:        newID,
		Task:      taskName,
		StartDate: start,
		EndDate:   end,
		Status:    status,
	}
	tasks = append(tasks, task)

	fmt.Println("Task added successfully!")
}

// Function to list all tasks
func listTasks() {
	if len(tasks) == 0 {
		fmt.Println("No tasks available.")
		return
	}

	fmt.Println("ID\tTask\t\tStart Date\tEnd Date\tStatus")
	fmt.Println("----------------------------------------------------------")
	for _, task := range tasks {
		fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
	}
}

// Function to move completed tasks to a new table (SQLite) and JSON file
func moveCompletedTasks(db *sql.DB) {
	// Move completed tasks to the `completed_tasks` table
	for _, task := range tasks {
		if task.Status == "Completed" {
			// Insert completed task into the completed_tasks table
			_, err := db.Exec(`INSERT INTO completed_tasks (id, task, start_date, end_date, status) 
				VALUES (?, ?, ?, ?, ?)`, task.ID, task.Task, task.StartDate, task.EndDate, task.Status)
			if err != nil {
				fmt.Println("Error moving task to completed tasks:", err)
				return
			}

			// Add the completed task to the completedTasks slice
			completedTasks = append(completedTasks, task)
		}
	}

	// Remove completed tasks from the tasks slice
	var remainingTasks []Task
	for _, task := range tasks {
		if task.Status != "Completed" {
			remainingTasks = append(remainingTasks, task)
		}
	}
	tasks = remainingTasks

	// Save completed tasks to a separate JSON file
	err := saveToJSON("completed_tasks.json", completedTasks)
	if err != nil {
		fmt.Println("Error saving completed tasks to JSON:", err)
	}
	fmt.Println("Completed tasks moved to completed_tasks table and saved in completed_tasks.json.")
}

// Function to save tasks to a JSON file
func saveToJSON(filename string, tasksToSave []Task) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(tasksToSave)
}

// Function to save tasks to a SQLite database
func saveToDatabase(db *sql.DB) error {
	for _, task := range tasks {
		_, err := db.Exec(`INSERT INTO tasks (id, task, start_date, end_date, status) 
			VALUES (?, ?, ?, ?, ?)`, task.ID, task.Task, task.StartDate, task.EndDate, task.Status)
		if err != nil {
			return err
		}
	}
	return nil
}

// Function to generate a PDF of the tasks
func generatePDF(filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(190, 10, "To-Do List", 0, 1, "C")

	// Set table header
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "ID")
	pdf.Cell(50, 10, "Task")
	pdf.Cell(30, 10, "Start Date")
	pdf.Cell(30, 10, "End Date")
	pdf.Cell(30, 10, "Status")
	pdf.Ln(10)

	// Set task data
	for _, task := range tasks {
		pdf.Cell(40, 10, fmt.Sprintf("%d", task.ID))
		pdf.Cell(50, 10, task.Task)
		pdf.Cell(30, 10, task.StartDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.EndDate.Format("2006-01-02"))
		pdf.Cell(30, 10, task.Status)
		pdf.Ln(8)
	}

	// Save the file
	return pdf.OutputFileAndClose(filename)
}

// Function to initialize SQLite database
func initializeDatabase() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./todo.db")
	if err != nil {
		return nil, err
	}

	// Create tables if they do not exist
	query := `CREATE TABLE IF NOT EXISTS tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);
	CREATE TABLE IF NOT EXISTS completed_tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);`
	_, err = db.Exec(query)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Function to load tasks from SQLite database
func loadFromDatabase(db *sql.DB) ([]Task, error) {
	rows, err := db.Query("SELECT id, task, start_date, end_date, status FROM tasks")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tasks []Task
	for rows.Next() {
		var task Task
		err := rows.Scan(&task.ID, &task.Task, &task.StartDate, &task.EndDate, &task.Status)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, task)
	}

	return tasks, nil
}

func main() {
	// Initialize SQLite database
	db, err := initializeDatabase()
	if err != nil {
		fmt.Println("Error initializing database:", err)
		return
	}
	defer db.Close()

	// Menu Loop
	for {
		fmt.Println("\nTo-Do List Menu:")
		fmt.Println("1. Add Task")
		fmt.Println("2. List Tasks")
		fmt.Println("3. Save to JSON File")
		fmt.Println("4. Save to Database")
		fmt.Println("5. Load from Database")
		fmt.Println("6. Generate PDF")
		fmt.Println("7. Move Completed Tasks")
		fmt.Println("8. Exit")

		var choice int
		fmt.Print("Enter your choice: ")
		fmt.Scanln(&choice)

		switch choice {
		case 1:
			addTask()
		case 2:
			listTasks()
		case 3:
			err := saveToJSON("tasks.json", tasks)
			if err != nil {
				fmt.Println("Error saving to JSON:", err)
			} else {
				fmt.Println("Tasks saved to tasks.json")
			}
		case 4:
			err := saveToDatabase(db)
			if err != nil {
				fmt.Println("Error saving tasks to database:", err)
			} else {
				fmt.Println("Tasks saved to database.")
			}
		case 5:
			tasksFromDB, err := loadFromDatabase(db)
			if err != nil {
				fmt.Println("Error loading tasks from database:", err)
			} else {
				fmt.Println("Tasks loaded from database:")
				for _, task := range tasksFromDB {
					fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
				}
			}
		case 6:
			err := generatePDF("tasks.pdf")
			if err != nil {
				fmt.Println("Error generating PDF:", err)
			} else {
				fmt.Println("Tasks saved to tasks.pdf")
			}
		case 7:
			moveCompletedTasks(db)
		case 8:
			fmt.Println("Goodbye!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}
```

### Explanation of Changes:

1. **Move Completed Tasks:**
   - The `moveCompletedTasks` function now moves completed tasks from the `tasks` table to the `completed_tasks` table in the SQLite database.
   - It also saves the completed tasks in a new JSON file, `completed_tasks.json`.

2. **Database Schema Changes:**
   - A new table `completed_tasks` is added to the SQLite database.
   - Completed tasks are stored in this new table, and they are removed from the `tasks` table.

3. **Menu Option:**
   - A new menu option is added to move completed tasks and save them in a different JSON file.
   - The user can choose to move completed tasks by selecting option 7 from the menu.

### How It Works:

1. **Add Task:** Adds a new task to the task list.
2. **List Tasks:** Displays the current tasks.
3. **Save to JSON File:** Saves all tasks in a JSON file (`tasks.json`).
4. **Save to Database:** Saves tasks to the SQLite database.
5. **Load from Database:** Loads tasks from the SQLite database.
6. **Generate PDF:** Generates a PDF with the list of tasks.
7. **Move Completed Tasks:** Moves completed tasks to the `completed_tasks` table in the database and saves them in a separate JSON file (`completed_tasks.json`).
8. **Exit:** Exits the program.

### Conclusion:

This version of the To-Do List program in Go supports an interactive user interface, task management, saving tasks to different formats (JSON, SQLite), and generating PDFs. It also moves completed tasks to a separate table and JSON file, ensuring better organization and tracking of task progress.

Let me know if you need further assistance or improvements!
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Sure! To make the Go program more modular and organized, we can separate it into different files. Here's a breakdown of how we can structure it:

### Project Structure:
```
todolist/
├── main.go
├── task.go
├── database.go
├── pdf.go
├── json.go
├── completed_tasks.go
└── go.mod
```

### 1. **main.go** - The entry point of the program.
### 2. **task.go** - Contains the `Task` struct and task-related functions (adding, listing).
### 3. **database.go** - Contains database functions (save, load, move completed tasks).
### 4. **pdf.go** - Contains PDF generation logic.
### 5. **json.go** - Functions for saving tasks to a JSON file.
### 6. **completed_tasks.go** - Logic to move completed tasks to a separate table.

### Let's go step by step:

#### `main.go`

```go
package main

import (
	"fmt"
	"todolist/database"
	"todolist/json"
	"todolist/pdf"
	"todolist/task"
	"time"
)

func main() {
	// Initialize SQLite database
	db, err := database.InitializeDatabase()
	if err != nil {
		fmt.Println("Error initializing database:", err)
		return
	}
	defer db.Close()

	// Menu Loop
	for {
		fmt.Println("\nTo-Do List Menu:")
		fmt.Println("1. Add Task")
		fmt.Println("2. List Tasks")
		fmt.Println("3. Save to JSON File")
		fmt.Println("4. Save to Database")
		fmt.Println("5. Load from Database")
		fmt.Println("6. Generate PDF")
		fmt.Println("7. Move Completed Tasks")
		fmt.Println("8. Exit")

		var choice int
		fmt.Print("Enter your choice: ")
		fmt.Scanln(&choice)

		switch choice {
		case 1:
			task.AddTask()
		case 2:
			task.ListTasks()
		case 3:
			json.SaveToJSON("tasks.json", task.Tasks)
		case 4:
			database.SaveToDatabase(db)
		case 5:
			tasksFromDB, err := database.LoadFromDatabase(db)
			if err != nil {
				fmt.Println("Error loading tasks from database:", err)
			} else {
				fmt.Println("Tasks loaded from database:")
				for _, t := range tasksFromDB {
					fmt.Printf("%d\t%s\t%s\t%s\t%s\n", t.ID, t.Task, t.StartDate.Format("2006-01-02"), t.EndDate.Format("2006-01-02"), t.Status)
				}
			}
		case 6:
			pdf.GeneratePDF("tasks.pdf")
		case 7:
			database.MoveCompletedTasks(db)
		case 8:
			fmt.Println("Goodbye!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}
```

#### `task.go`

```go
package task

import (
	"fmt"
	"time"
)

type Task struct {
	ID        int       `json:"id"`
	Task      string    `json:"task"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Status    string    `json:"status"`
}

var Tasks []Task

// Add a task to the list
func AddTask() {
	var taskName, status string
	var startDate, endDate string

	// Prompt user for task details
	fmt.Println("Enter task name:")
	fmt.Scanln(&taskName)

	fmt.Println("Enter start date (YYYY-MM-DD):")
	fmt.Scanln(&startDate)

	fmt.Println("Enter end date (YYYY-MM-DD):")
	fmt.Scanln(&endDate)

	fmt.Println("Enter status (Pending/In Progress/Completed):")
	fmt.Scanln(&status)

	// Convert string to time.Time
	start, err := time.Parse("2006-01-02", startDate)
	if err != nil {
		fmt.Println("Invalid start date format.")
		return
	}

	end, err := time.Parse("2006-01-02", endDate)
	if err != nil {
		fmt.Println("Invalid end date format.")
		return
	}

	// Generate new ID for the task
	newID := len(Tasks) + 1

	// Create and add the task to the list
	task := Task{
		ID:        newID,
		Task:      taskName,
		StartDate: start,
		EndDate:   end,
		Status:    status,
	}
	Tasks = append(Tasks, task)

	fmt.Println("Task added successfully!")
}

// List all tasks
func ListTasks() {
	if len(Tasks) == 0 {
		fmt.Println("No tasks available.")
		return
	}

	fmt.Println("ID\tTask\t\tStart Date\tEnd Date\tStatus")
	fmt.Println("----------------------------------------------------------")
	for _, task := range Tasks {
		fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
	}
}
```

#### `database.go`

```go
package database

import (
	"database/sql"
	"fmt"
	"todolist/task"
	_ "github.com/mattn/go-sqlite3"
)

// Initialize SQLite database
func InitializeDatabase() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./todo.db")
	if err != nil {
		return nil, err
	}

	// Create tables if they do not exist
	query := `CREATE TABLE IF NOT EXISTS tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);
	CREATE TABLE IF NOT EXISTS completed_tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);`
	_, err = db.Exec(query)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Save tasks to SQLite database
func SaveToDatabase(db *sql.DB) error {
	for _, t := range task.Tasks {
		_, err := db.Exec(`INSERT INTO tasks (id, task, start_date, end_date, status) 
			VALUES (?, ?, ?, ?, ?)`, t.ID, t.Task, t.StartDate, t.EndDate, t.Status)
		if err != nil {
			return err
		}
	}
	return nil
}

// Load tasks from SQLite database
func LoadFromDatabase(db *sql.DB) ([]task.Task, error) {
	rows, err := db.Query("SELECT id, task, start_date, end_date, status FROM tasks")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tasks []task.Task
	for rows.Next() {
		var t task.Task
		err := rows.Scan(&t.ID, &t.Task, &t.StartDate, &t.EndDate, &t.Status)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, t)
	}

	return tasks, nil
}

// Move completed tasks to the completed_tasks table
func MoveCompletedTasks(db *sql.DB) {
	// Move completed tasks to the completed_tasks table
	for _, t := range task.Tasks {
		if t.Status == "Completed" {
			_, err := db.Exec(`INSERT INTO completed_tasks (id, task, start_date, end_date, status) 
				VALUES (?, ?, ?, ?, ?)`, t.ID, t.Task, t.StartDate, t.EndDate, t.Status)
			if err != nil {
				fmt.Println("Error moving task to completed tasks:", err)
				return
			}
		}
	}

	// Remove completed tasks from the tasks slice
	var remainingTasks []task.Task
	for _, t := range task.Tasks {
		if t.Status != "Completed" {
			remainingTasks = append(remainingTasks, t)
		}
	}
	task.Tasks = remainingTasks

	// Save completed tasks to a separate JSON file
	fmt.Println("Completed tasks moved to the database.")
}
```

#### `pdf.go`

```go
package pdf

import (
	"fmt"
	"todolist/task"
	"github.com/jung-kurt/gofpdf"
)

// Generate PDF of tasks
func GeneratePDF(filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(190, 10, "To-Do List", 0, 1, "C")

	// Set table header
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "ID")
	pdf.Cell(50, 10, "Task")
	pdf.Cell(30, 10, "Start Date")
	pdf.Cell(30, 10, "End Date")
	pdf.Cell(30, 10, "Status")
	pdf.Ln(10)

	// Set task data
	for _, t := range task.Tasks {
		pdf.Cell(40, 10, fmt.Sprintf("%d", t.ID))
		pdf.Cell(50, 10, t.Task)
		pdf.Cell(30, 10, t.StartDate.Format("2006-01-02"))
		pdf.Cell(30, 10, t.EndDate.Format("2006-01-02"))
		pdf.Cell(30, 10, t.Status)
		pdf.Ln(8)
	}

	// Save the file
	return pdf.OutputFileAndClose(filename)
}
```

#### `json.go`

```go
package json

import (
	"encoding/json"
	"fmt"
	"os"
	"todolist/task"
)

// Save tasks to a JSON file
func SaveToJSON(filename string, tasksToSave []task.Task) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(tasksToSave)
}
```

### How to Run:

1. **Install Dependencies**:
   - If you don't have the `gofpdf` and `sqlite3` packages yet, install them with:
     ```bash
     go get github.com/jung-kurt/gofpdf
     go get github.com/mattn/go-sqlite3
     ```

2. **Run the Program**:
   ```bash
   go run main.go
   ```

### Conclusion:

This approach divides the program into multiple Go files to improve modularity
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Certainly! Below is the fully updated Go project that includes a user interactive menu with options to manage tasks (add, list, save to files, move completed tasks, etc.). Each part of the program is separated into different files for better structure and organization. The program allows the user to interactively add tasks, list tasks, save tasks to JSON and a SQLite database, generate a PDF of tasks, and move completed tasks to a separate table and JSON file.

### Project Structure:

```
todolist/
├── main.go
├── task.go
├── database.go
├── pdf.go
├── json.go
├── completed_tasks.go
├── go.mod
└── go.sum
```

### `main.go` - Entry Point

This file contains the main program loop that displays the menu and calls relevant functions based on user input.

```go
package main

import (
	"fmt"
	"todolist/database"
	"todolist/json"
	"todolist/pdf"
	"todolist/task"
	"time"
)

func main() {
	// Initialize SQLite database
	db, err := database.InitializeDatabase()
	if err != nil {
		fmt.Println("Error initializing database:", err)
		return
	}
	defer db.Close()

	// Menu Loop
	for {
		fmt.Println("\nTo-Do List Menu:")
		fmt.Println("1. Add Task")
		fmt.Println("2. List Tasks")
		fmt.Println("3. Save Tasks to JSON File")
		fmt.Println("4. Save Tasks to Database")
		fmt.Println("5. Load Tasks from Database")
		fmt.Println("6. Generate PDF of Tasks")
		fmt.Println("7. Move Completed Tasks")
		fmt.Println("8. Exit")

		var choice int
		fmt.Print("Enter your choice: ")
		fmt.Scanln(&choice)

		switch choice {
		case 1:
			task.AddTask()
		case 2:
			task.ListTasks()
		case 3:
			json.SaveToJSON("tasks.json", task.Tasks)
		case 4:
			database.SaveToDatabase(db)
		case 5:
			tasksFromDB, err := database.LoadFromDatabase(db)
			if err != nil {
				fmt.Println("Error loading tasks from database:", err)
			} else {
				fmt.Println("Tasks loaded from database:")
				for _, t := range tasksFromDB {
					fmt.Printf("%d\t%s\t%s\t%s\t%s\n", t.ID, t.Task, t.StartDate.Format("2006-01-02"), t.EndDate.Format("2006-01-02"), t.Status)
				}
			}
		case 6:
			pdf.GeneratePDF("tasks.pdf")
		case 7:
			database.MoveCompletedTasks(db)
		case 8:
			fmt.Println("Goodbye!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}
```

### `task.go` - Task Management Functions

This file contains the `Task` struct and functions for adding tasks, listing tasks, and storing tasks in a slice.

```go
package task

import (
	"fmt"
	"time"
)

type Task struct {
	ID        int       `json:"id"`
	Task      string    `json:"task"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	Status    string    `json:"status"`
}

var Tasks []Task

// Add a task to the list
func AddTask() {
	var taskName, status string
	var startDate, endDate string

	// Prompt user for task details
	fmt.Println("Enter task name:")
	fmt.Scanln(&taskName)

	fmt.Println("Enter start date (YYYY-MM-DD):")
	fmt.Scanln(&startDate)

	fmt.Println("Enter end date (YYYY-MM-DD):")
	fmt.Scanln(&endDate)

	fmt.Println("Enter status (Pending/In Progress/Completed):")
	fmt.Scanln(&status)

	// Convert string to time.Time
	start, err := time.Parse("2006-01-02", startDate)
	if err != nil {
		fmt.Println("Invalid start date format.")
		return
	}

	end, err := time.Parse("2006-01-02", endDate)
	if err != nil {
		fmt.Println("Invalid end date format.")
		return
	}

	// Generate new ID for the task
	newID := len(Tasks) + 1

	// Create and add the task to the list
	task := Task{
		ID:        newID,
		Task:      taskName,
		StartDate: start,
		EndDate:   end,
		Status:    status,
	}
	Tasks = append(Tasks, task)

	fmt.Println("Task added successfully!")
}

// List all tasks
func ListTasks() {
	if len(Tasks) == 0 {
		fmt.Println("No tasks available.")
		return
	}

	fmt.Println("ID\tTask\t\tStart Date\tEnd Date\tStatus")
	fmt.Println("----------------------------------------------------------")
	for _, task := range Tasks {
		fmt.Printf("%d\t%s\t%s\t%s\t%s\n", task.ID, task.Task, task.StartDate.Format("2006-01-02"), task.EndDate.Format("2006-01-02"), task.Status)
	}
}
```

### `database.go` - Database Management Functions

This file contains functions for interacting with the SQLite database to save, load, and move tasks.

```go
package database

import (
	"database/sql"
	"fmt"
	"todolist/task"
	_ "github.com/mattn/go-sqlite3"
)

// Initialize SQLite database
func InitializeDatabase() (*sql.DB, error) {
	db, err := sql.Open("sqlite3", "./todo.db")
	if err != nil {
		return nil, err
	}

	// Create tables if they do not exist
	query := `CREATE TABLE IF NOT EXISTS tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);
	CREATE TABLE IF NOT EXISTS completed_tasks (
		id INTEGER PRIMARY KEY,
		task TEXT,
		start_date DATE,
		end_date DATE,
		status TEXT
	);`
	_, err = db.Exec(query)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Save tasks to SQLite database
func SaveToDatabase(db *sql.DB) error {
	for _, t := range task.Tasks {
		_, err := db.Exec(`INSERT INTO tasks (id, task, start_date, end_date, status) 
			VALUES (?, ?, ?, ?, ?)`, t.ID, t.Task, t.StartDate, t.EndDate, t.Status)
		if err != nil {
			return err
		}
	}
	return nil
}

// Load tasks from SQLite database
func LoadFromDatabase(db *sql.DB) ([]task.Task, error) {
	rows, err := db.Query("SELECT id, task, start_date, end_date, status FROM tasks")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tasks []task.Task
	for rows.Next() {
		var t task.Task
		err := rows.Scan(&t.ID, &t.Task, &t.StartDate, &t.EndDate, &t.Status)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, t)
	}

	return tasks, nil
}

// Move completed tasks to the completed_tasks table
func MoveCompletedTasks(db *sql.DB) {
	// Move completed tasks to the completed_tasks table
	for _, t := range task.Tasks {
		if t.Status == "Completed" {
			_, err := db.Exec(`INSERT INTO completed_tasks (id, task, start_date, end_date, status) 
				VALUES (?, ?, ?, ?, ?)`, t.ID, t.Task, t.StartDate, t.EndDate, t.Status)
			if err != nil {
				fmt.Println("Error moving task to completed tasks:", err)
				return
			}
		}
	}

	// Remove completed tasks from the tasks slice
	var remainingTasks []task.Task
	for _, t := range task.Tasks {
		if t.Status != "Completed" {
			remainingTasks = append(remainingTasks, t)
		}
	}
	task.Tasks = remainingTasks

	// Save completed tasks to a separate JSON file
	fmt.Println("Completed tasks moved to the database.")
}
```

### `pdf.go` - PDF Generation

This file contains the logic to generate a PDF containing the tasks.

```go
package pdf

import (
	"fmt"
	"todolist/task"
	"github.com/jung-kurt/gofpdf"
)

// Generate PDF of tasks
func GeneratePDF(filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(190, 10, "To-Do List", 0, 1, "C")

	// Set table header
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "ID")
	pdf.Cell(50, 10, "Task")
	pdf.Cell(30, 10, "Start Date")
	pdf.Cell(30, 10, "End Date")
	pdf.Cell(30, 10, "Status")
	pdf.Ln(10)

	// Set task data
	for _, t := range task.Tasks {
		pdf.Cell(40, 10, fmt.Sprintf("%d", t.ID))
		pdf.Cell(50, 10, t.Task)
		pdf.Cell(30, 10, t.StartDate.Format("2006-01-02"))
		pdf.Cell(30, 10, t.EndDate.Format("2006-01-02"))
		pdf.Cell(30, 10, t.Status)
		pdf.Ln(8)
	}

	// Save the file
	return pdf.OutputFileAndClose(filename)
}
```

### `json.go` - JSON File Handling

This file handles saving tasks to a JSON file.

```go
package json

import (
	"encoding/json"
	"fmt"
	"os"
	"todolist/task"
)

// Save tasks to a JSON file
func SaveToJSON(filename string, tasksToSave []task.Task) error {
	file, err := os.Create

(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	return encoder.Encode(tasksToSave)
}
```

### Conclusion

This Go program provides a full menu-based task management system where you can:

1. Add tasks.
2. List tasks.
3. Save tasks to a JSON file.
4. Save tasks to a database.
5. Load tasks from the database.
6. Generate a PDF of tasks.
7. Move completed tasks to another table and separate JSON file.

To run the program, use `go run main.go` after setting up your Go environment and installing the necessary dependencies (`gofpdf`, `sqlite3`).